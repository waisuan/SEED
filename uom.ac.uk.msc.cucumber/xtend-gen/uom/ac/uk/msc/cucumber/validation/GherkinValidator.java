/**
 * generated by Xtext
 */
package uom.ac.uk.msc.cucumber.validation;

import com.google.common.base.Objects;
import java.util.ArrayList;
import org.eclipse.emf.ecore.EAttribute;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Exceptions;
import uom.ac.uk.msc.cucumber.gherkin.Background;
import uom.ac.uk.msc.cucumber.gherkin.Feature;
import uom.ac.uk.msc.cucumber.gherkin.Scenario;
import uom.ac.uk.msc.cucumber.gherkin.ScenarioOutline;
import uom.ac.uk.msc.cucumber.gherkin.Step;
import uom.ac.uk.msc.cucumber.java.CucumberAdviser;
import uom.ac.uk.msc.cucumber.java.CucumberBackgrounder;
import uom.ac.uk.msc.cucumber.java.CucumberCodeConstants;
import uom.ac.uk.msc.cucumber.java.CucumberDuplicateChecker;
import uom.ac.uk.msc.cucumber.java.CucumberFileHandler;
import uom.ac.uk.msc.cucumber.java.CucumberWrapper;
import uom.ac.uk.msc.cucumber.validation.AbstractGherkinValidator;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class GherkinValidator extends AbstractGherkinValidator {
  public final static String STEP_REPEATED_IN_EVERY_SCENARIO = "potentialBackgroundStep";
  
  public final static String CONSECUTIVE_STEPS = "consecutiveSteps";
  
  public final static String SEPARATE_TO_AND_STEPS = "splitToAndStep";
  
  public final static String SEPARATE_TO_BUT_STEPS = "splitToButStep";
  
  public final static String SIMILAR_SCENARIOS = "changeToScenarioOutline";
  
  public final static String SCENARIOS_HAVE_TO_BE_UNIQUE = "duplicateScenario";
  
  public final static String FEATURES_HAVE_TO_BE_UNIQUE = "duplicateFeature";
  
  public final static String DUPLICATE_STEP = "duplicateStep";
  
  public final static String STEP_EXISTS_IN_BACKGROUND = "stepExistsInBackground";
  
  public final static String REPEATED_EXAMPLES_TABLE_ROWS = "repeatedExamplesTableRows";
  
  public final static String SIMILAR_SCENARIO_TITLES = "similarScenarioTitle";
  
  public final static String SIMILAR_STEPS = "similarSteps";
  
  public final static String SIMILAR_STEP_EXISTS_IN_BACKGROUND = "similarStepExistsInBackground";
  
  @Check
  public void checkIfFeatureIsUnique(final Feature feature) {
    try {
      ArrayList<CucumberWrapper> listOfWrappers = CucumberFileHandler.loadFeatureFilesAndCheckForDuplicateFeatureTitles(feature);
      for (final CucumberWrapper wrapper : listOfWrappers) {
        String _code = wrapper.getCode();
        String _code_1 = CucumberCodeConstants.SIMILAR_FEATURE_TITLES.getCode();
        boolean _equals = _code.equals(_code_1);
        if (_equals) {
          String _message = wrapper.getMessage();
          EObject _source = wrapper.getSource();
          EAttribute _literal = wrapper.getLiteral();
          String _code_2 = wrapper.getCode();
          String[] _data = wrapper.getData();
          this.warning(_message, _source, _literal, _code_2, _data);
        } else {
          String _message_1 = wrapper.getMessage();
          EObject _source_1 = wrapper.getSource();
          EAttribute _literal_1 = wrapper.getLiteral();
          String _code_3 = wrapper.getCode();
          String[] _data_1 = wrapper.getData();
          this.error(_message_1, _source_1, _literal_1, _code_3, _data_1);
        }
      }
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
  
  @Check
  public void checkIfScenarioIsUnique(final Feature feature) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfScenarioIsUnique(feature);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _code = wrapper.getCode();
      String _code_1 = CucumberCodeConstants.SIMILAR_SCENARIO_TITLES.getCode();
      boolean _equals = _code.equals(_code_1);
      if (_equals) {
        String _message = wrapper.getMessage();
        EObject _source = wrapper.getSource();
        EAttribute _literal = wrapper.getLiteral();
        String _code_2 = wrapper.getCode();
        String[] _data = wrapper.getData();
        this.warning(_message, _source, _literal, _code_2, _data);
      } else {
        String _message_1 = wrapper.getMessage();
        EObject _source_1 = wrapper.getSource();
        EAttribute _literal_1 = wrapper.getLiteral();
        String _code_3 = wrapper.getCode();
        String[] _data_1 = wrapper.getData();
        this.error(_message_1, _source_1, _literal_1, _code_3, _data_1);
      }
    }
  }
  
  @Check
  public void checkIfStepsInScenarioAreUnique(final Scenario scenario) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfStepsInScenarioAreUnique(scenario);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfStepsInScenarioOutlineAreUnique(final ScenarioOutline scenario) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfStepsInScenarioOutlineAreUnique(scenario);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkForGivenStepsThatCanBeMovedIntoTheBackground(final Feature feature) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberBackgrounder.checkForGivenStepsThatCanBeMovedIntoTheBackground(feature);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfStepsAreAlreadyInBackground(final Feature feature) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfStepsAreAlreadyInBackground(feature);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfStepsInBackgroundAreUnique(final Background background) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfStepsInBackgroundAreUnique(background);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkForConsecutiveGivenWhenThenSteps(final Feature feature) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkForConsecutiveGivenWhenThenSteps(feature);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfScenarioIsTooLongOrTooShort(final Scenario scenario) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfScenarioIsTooLongOrTooShort(scenario);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfScenarioOutlineIsTooLongOrTooShort(final ScenarioOutline scenarioOutline) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfScenarioOutlineIsTooLongOrTooShort(scenarioOutline);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfBackgroundIsTooLong(final Background background) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfBackgroundIsTooLong(background);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfThereAreMoreThanOneWhenStepInAScenario(final Scenario scenario) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfThereAreMoreThanOneWhenStepInAScenario(scenario);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfThereAreMoreThanOneWhenStepInAScenarioOutline(final ScenarioOutline scenarioOutline) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfThereAreMoreThanOneWhenStepInAScenarioOutline(scenarioOutline);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfStepContainsTheWordAnd(final Step step) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfStepContainsTheWordAnd(step);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfStepContainsTheWordBut(final Step step) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfStepContainsTheWordBut(step);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfScenariosCanBeAlteredToScenarioOutline(final Feature feature) {
    ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfScenariosCanBeAlteredToScenarioOutline(feature);
    for (final CucumberWrapper wrapper : listOfWrappers) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
  
  @Check
  public void checkIfRowsInExamplesTableAreUnique(final ScenarioOutline scenarioOutline) {
    CucumberWrapper wrapper = CucumberDuplicateChecker.checkIfRowsInExamplesTableAreUnique(scenarioOutline);
    boolean _notEquals = (!Objects.equal(null, wrapper));
    if (_notEquals) {
      String _message = wrapper.getMessage();
      EObject _source = wrapper.getSource();
      EAttribute _literal = wrapper.getLiteral();
      String _code = wrapper.getCode();
      String[] _data = wrapper.getData();
      this.warning(_message, _source, _literal, _code, _data);
    }
  }
}
