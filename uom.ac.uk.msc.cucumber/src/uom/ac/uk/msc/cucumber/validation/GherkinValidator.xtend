/*
 * generated by Xtext
 */
package uom.ac.uk.msc.cucumber.validation

import org.eclipse.xtext.validation.Check
import uom.ac.uk.msc.cucumber.gherkin.Scenario
import uom.ac.uk.msc.cucumber.gherkin.Feature
import uom.ac.uk.msc.cucumber.gherkin.GherkinPackage
import uom.ac.uk.msc.cucumber.gherkin.Step
import uom.ac.uk.msc.cucumber.gherkin.Background
import java.util.HashSet
import uom.ac.uk.msc.cucumber.gherkin.ScenarioOutline
import uom.ac.uk.msc.cucumber.java.CucumberFileHandler
import java.util.HashMap
import java.util.List
import java.util.ArrayList
import java.util.Map.Entry
import org.eclipse.xtext.nodemodel.util.NodeModelUtils
import org.eclipse.xtext.nodemodel.INode
import java.util.Collection
import java.util.Collections
import java.util.Comparator
import java.math.BigDecimal
import uom.ac.uk.msc.cucumber.java.CucumberDuplicateChecker
import uom.ac.uk.msc.cucumber.java.CucumberWrapper
import org.eclipse.emf.ecore.EObject
import uom.ac.uk.msc.cucumber.java.CucumberCodeConstants
import uom.ac.uk.msc.cucumber.java.CucumberMessageConstants
import uom.ac.uk.msc.cucumber.java.CucumberBackgrounder
import uom.ac.uk.msc.cucumber.java.CucumberAdviser

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class GherkinValidator extends AbstractGherkinValidator {

	public static val STEP_REPEATED_IN_EVERY_SCENARIO = "potentialBackgroundStep"
	public static val CONSECUTIVE_STEPS = "consecutiveSteps"
	public static val SEPARATE_TO_AND_STEPS = "splitToAndStep"
	public static val SEPARATE_TO_BUT_STEPS = "splitToButStep"
	public static val SIMILAR_SCENARIOS = "changeToScenarioOutline"
	public static val SCENARIOS_HAVE_TO_BE_UNIQUE = "duplicateScenario"
	public static val FEATURES_HAVE_TO_BE_UNIQUE = "duplicateFeature"
	public static val DUPLICATE_STEP = "duplicateStep"
	public static val STEP_EXISTS_IN_BACKGROUND = "stepExistsInBackground"
	public static val REPEATED_EXAMPLES_TABLE_ROWS = "repeatedExamplesTableRows"
	public static val SIMILAR_SCENARIO_TITLES = "similarScenarioTitle"
	public static val SIMILAR_STEPS = "similarSteps"
	public static val SIMILAR_STEP_EXISTS_IN_BACKGROUND = "similarStepExistsInBackground"
	
	@Check
	def void checkIfFeatureIsUnique(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberFileHandler.
			loadFeatureFilesAndCheckForDuplicateFeatureTitles(feature);
		for (wrapper : listOfWrappers) {
			if (wrapper.getCode().equals(CucumberCodeConstants.SIMILAR_FEATURE_TITLES.getCode())) {
				warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
					wrapper.getData());
			} else
				error(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
					wrapper.getData());
		}
	}

	@Check
	def void checkIfScenarioIsUnique(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.checkIfScenarioIsUnique(feature);
		for (wrapper : listOfWrappers) {
			if (wrapper.getCode().equals(CucumberCodeConstants.SIMILAR_SCENARIO_TITLES.getCode())) {
				warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
					wrapper.getData())
			} else
				error(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
					wrapper.getData());
		}
	}

	@Check
	def void checkIfStepsInScenarioAreUnique(Scenario scenario) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.
			checkIfStepsInScenarioAreUnique(scenario);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfStepsInScenarioOutlineAreUnique(ScenarioOutline scenario) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.
			checkIfStepsInScenarioOutlineAreUnique(scenario);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkForGivenStepsThatCanBeMovedIntoTheBackground(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberBackgrounder.
			checkForGivenStepsThatCanBeMovedIntoTheBackground(feature);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfStepsAreAlreadyInBackground(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.
			checkIfStepsAreAlreadyInBackground(feature);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfStepsInBackgroundAreUnique(Background background) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.
			checkIfStepsInBackgroundAreUnique(background);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkForConsecutiveGivenWhenThenSteps(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkForConsecutiveGivenWhenThenSteps(feature);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfScenarioIsTooLongOrTooShort(Scenario scenario) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfScenarioIsTooLongOrTooShort(scenario);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfScenarioOutlineIsTooLongOrTooShort(ScenarioOutline scenarioOutline) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.
			checkIfScenarioOutlineIsTooLongOrTooShort(scenarioOutline);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfBackgroundIsTooLong(Background background) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfBackgroundIsTooLong(background);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfThereAreMoreThanOneWhenStepInAScenario(Scenario scenario) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.
			checkIfThereAreMoreThanOneWhenStepInAScenario(scenario);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfThereAreMoreThanOneWhenStepInAScenarioOutline(ScenarioOutline scenarioOutline) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.
			checkIfThereAreMoreThanOneWhenStepInAScenarioOutline(scenarioOutline);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfStepContainsTheWordAnd(Step step) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfStepContainsTheWordAnd(step);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}
	
	@Check
	def void checkIfStepContainsTheWordBut(Step step) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberAdviser.checkIfStepContainsTheWordBut(step);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfScenariosCanBeAlteredToScenarioOutline(Feature feature) {
		var ArrayList<CucumberWrapper> listOfWrappers = CucumberDuplicateChecker.
			checkIfScenariosCanBeAlteredToScenarioOutline(feature);
		for (wrapper : listOfWrappers) {
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}

	@Check
	def void checkIfRowsInExamplesTableAreUnique(ScenarioOutline scenarioOutline) {
		var CucumberWrapper wrapper = CucumberDuplicateChecker.checkIfRowsInExamplesTableAreUnique(scenarioOutline);
		if(null != wrapper){
			warning(wrapper.getMessage(), wrapper.getSource(), wrapper.getLiteral(), wrapper.getCode(),
				wrapper.getData());
		}
	}
}
